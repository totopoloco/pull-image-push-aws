name: "Test to deploy SciCat backend"
run-name: Deploy SciCat Backend to AWS by @${{ github.actor }}

on:
  workflow_dispatch:
    inputs:
      environment:
        description: "The environment to deploy to"
        required: true
        default: 'integration'
        type: choice
        options:
          - integration
          - staging
          - production
env:
  AWS_REGION: eu-central-1
  SCICAT_IMAGE: ghcr.io/scicatproject/backend-next:latest

permissions:
  contents: read
  id-token: write

jobs:
  prepare-scicat-image:
    name: Prepare SciCat Docker Image
    runs-on: ubuntu-latest
    environment:
      name: ${{ github.event.inputs.environment }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Create config files
        run: |
          mkdir -p config
          cat > config/functionalAccounts.json <<EOF
          [
           {
              "username": "admin",
              "email": "admin@scicat.project",
              "password": "27f5fd86ae68fe740eef42b8bbd1d7d5",
              "role": "admin",
              "global": true
           }
          ]
          EOF

          cat > config/proposalTypes.json << EOF
          {    
            "DOORProposal": "DOOR Proposal",
            "Beamtime": "Beamtime"
          }
          EOF
      - name: Login to GitHub Container Registry
        uses: docker/login-action@v2
        with:
          registry: ghcr.io
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
        # Display the login status if the login was successful
        if: always()

      - name: Pull SciCat Docker Image
        run: |
          docker create --name scicat_temp ${{ env.SCICAT_IMAGE }}
          docker cp config/functionalAccounts.json scicat_temp:/home/node/app/functionalAccounts.json
          docker cp config/proposalTypes.json scicat_temp:/home/node/app/proposalTypes.json
          docker commit scicat_temp scicat_configured
        if: always()

      #      - name: Delete container to test above steps
      #        run: |
      #          docker rm scicat_temp
      #          docker rmi ${{ env.SCICAT_IMAGE }}
      #          docker rmi scicat_configured
      #        if: always()

      - id: credentials-image-push
        name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-region: ${{ env.AWS_REGION }}
          role-to-assume: ${{ secrets.ROLE_ARN_DEPLOY }}
          role-session-name: ${{ github.actor_id }}-${{ github.run_id }}
          mask-aws-account-id: false # masking would affect unrelated steps if configured
        if: always()

      - id: login-ecr-push
        name: Login to AWS ECR
        uses: aws-actions/amazon-ecr-login@v2
        if: always()

      - name: Tag and push SciCat Docker Image
        id: push-image
        env:
          ECR_REGISTRY: ${{ steps.login-ecr-push.outputs.registry }}
          ECR_REPOSITORY: scicat-backend
        run: |
          # Tag with SHA for immutability
          IMAGE_TAG=$(echo ${{ github.sha }} | cut -c1-7)-$(date +%s)
          FULL_IMAGE_URL=${ECR_REGISTRY}/${ECR_REPOSITORY}:${IMAGE_TAG}

          # Check if repository exists without showing error output
          aws ecr describe-repositories --repository-names "${ECR_REPOSITORY}" 2>/dev/null || \
          echo "Repository doesn't exist, creating now..." && \
          aws ecr create-repository --repository-name "${ECR_REPOSITORY}"
  
          docker tag scicat_configured ${FULL_IMAGE_URL}
          docker push ${FULL_IMAGE_URL}
          echo "image_url=${FULL_IMAGE_URL}" >> $GITHUB_OUTPUT
        if: always()
    outputs:
      image_url: ${{ steps.push-image.outputs.image_url }}

  validate-aws-access:
    name: Validate AWS Access
    runs-on: ubuntu-latest
    environment: ${{ github.event.inputs.environment }}
    steps:
      - id: assume-role
        name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-region: ${{ env.AWS_REGION }}
          role-to-assume: ${{ secrets.ROLE_ARN_DEPLOY }}
          role-session-name: ${{ github.actor_id }}-${{ github.run_id }}
          mask-aws-account-id: false # masking would affect unrelated steps if configured
        if: always()
      - name: Verify AWS access
        id: verify-aws-access
        run: |
          printf "aws_role_arn=%s\n" '${{ vars.ROLE_ARN_DEPLOY }}' >> "$GITHUB_OUTPUT"
          printf "aws_region=%s\n" "$AWS_REGION" >> "$GITHUB_OUTPUT"
          aws sts get-caller-identity --query Arn --output text
        if: always()
    outputs:
       aws_region: ${{ steps.verify-aws-access.outputs.aws_region }}
       aws_role_arn: ${{ steps.verify-aws-access.outputs.aws_role_arn }}
       # terraform_environment_name: ${{ vars.TERRAFORM_ENVIRONMENT_NAME }} # TODO: Add this to the outputruns-on: